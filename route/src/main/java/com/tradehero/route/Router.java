package com.tradehero.route;

import android.app.Activity;
import android.content.Context;
import android.content.Intent;
import android.os.Bundle;
import android.util.Log;
import com.tradehero.route.internal.RouterProcessor;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.Map;

public class Router {
  private static final String TAG = "Router";
  private static boolean debug = true;
  protected final Map<String, Class<? extends Activity>> routes =
      new HashMap<String, Class<? extends Activity>>();

  private Context context;

  public interface Injector<T> {
    void inject(final T target, Bundle source);
    void save(final T source, Bundle dest, boolean flat);
  }

  public static abstract class RoutableInjector<T> implements Injector<T> {
    public PathPattern[] pathPatterns() { return null; }
  }

  static final Map<Class<?>, Injector<?>> INJECTORS = new LinkedHashMap<Class<?>, Injector<?>>();

  static final Injector<?> NO_OP = null;

  /**
   * Creates a new Router
   */
  public Router() {
  }

  private static final Router router = new Router();

  /**
   * A globally accessible Router instance that will work for
   * most use cases.
   */
  public static Router getInstance() {
    return router;
  }

  /**
   * Creates a new Router
   *
   * @param context {@link android.content.Context} that all {@link android.content.Intent}s
   * generated by the router will use
   */
  public Router(Context context) {
    this.setContext(context);
  }

  /**
   * @param context {@link android.content.Context} that all {@link android.content.Intent}s
   * generated by the router will use
   */
  public void setContext(Context context) {
    this.context = context.getApplicationContext();
  }

  /**
   * Map a URL to open an {@link android.app.Activity}
   *
   * @param format The URL being mapped; for example, "users/:id" or "groups/:id/topics/:topic_id"
   * @param klass The {@link android.app.Activity} class to be opened with the URL
   * for when the URL is opened
   */
  public void map(String format, Class<? extends Activity> klass) {
    this.routes.put(format, klass);
  }

  /**
   * @param url The URL; for example, "users/16" or "groups/5/topics/20"
   */
  public void open(String url) {
    this.open(url, this.context);
  }

  /**
   *
   * @param url The URL; for example, "users/16" or "groups/5/topics/20"
   * @param context The context which is used in the generated {@link android.content.Intent}
   */
  public void open(String url, Context context) {
    if (context == null) {
      throw new RuntimeException("You need to supply a context for Router " + this.toString());
    }

    Intent intent = this.intentFor(context, url);
    if (intent == null) {
      // Means the options weren't opening a new activity
      return;
    }
    context.startActivity(intent);
  }

  /**
   * @param context The context which is spawning the intent
   * @param url The URL; for example, "users/16" or "groups/5/topics/20"
   * @return The {@link android.content.Intent} for the url, with the correct {@link
   * android.app.Activity} set, or null.
   */
  public Intent intentFor(Context context, String url) {
    Intent intent = new Intent();
    //intent.setClass(context, options.klass);
    if (context == this.context) {
      intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
    }
    return intent;
  }

  public void inject(Activity activity) {
    Bundle extras = activity.getIntent() != null ? activity.getIntent().getExtras() : null;
    inject(activity, extras);
  }

  public void inject(Object target, Bundle extras) {
    Class<?> targetClass = target.getClass();
    try {
      if (debug) Log.d(TAG, "Looking up injector for " + targetClass.getName());
      @SuppressWarnings("unchecked")
      Injector<Object> injector = (Injector<Object>) findInjectorForClass(targetClass);
      if (injector != null) {
        injector.inject(target, extras);
      }
    } catch (RuntimeException e) {
      throw e;
    } catch (Exception e) {
      throw new RuntimeException("Unable to inject for " + target, e);
    }
  }

  /** Save POJO to bundle with hierarchy */
  public void save(Bundle extras, Object... parcelables) {
    if (parcelables == null) return;

    boolean flat = false;
    int length = parcelables.length;

    if (length > 1 && parcelables[length - 1] instanceof Boolean) {
      flat = (Boolean) parcelables[length - 1];
      --length;
    }

    for (int i = 0; i< length;  ++i) {
      saveSingle(extras, parcelables[i], flat);
    }
  }

  /** Save POJO to bundle without hierarchy */
  public void saveFlat(Bundle extras, Object... parcelables) {
    for (Object parcelable: parcelables) {
      saveSingle(extras, parcelable, true);
    }
  }

  public void saveSingle(Bundle extras, Object parcelable, boolean flat) {
    Class<?> targetClass = parcelable.getClass();
    try {
      if (debug) Log.d(TAG, "Looking up saver for " + targetClass.getName());
      @SuppressWarnings("unchecked")
      Injector<Object> inject = (Injector<Object>) findInjectorForClass(targetClass);
      if (inject != null) {
        inject.save(parcelable, extras, flat);
      }
    } catch (RuntimeException e) {
      throw e;
    } catch (Exception e) {
      throw new RuntimeException("Unable to inject for " + parcelable, e);
    }
  }

  private static Injector<?> findInjectorForClass(Class<?> cls)
      throws NoSuchMethodException, IllegalAccessException, InstantiationException {
    Injector<?> injector = INJECTORS.get(cls);
    if (injector != null) {
      if (debug) Log.d(TAG, "HIT: Cached in injector map.");
      return injector;
    }
    String clsName = cls.getName();
    if (clsName.startsWith("android.") || clsName.startsWith("java.")) {
      if (debug) Log.d(TAG, "MISS: Reached framework class. Abandoning search.");
      return NO_OP;
    }
    try {
      injector = (Injector<?>) Class.forName(clsName + RouterProcessor.SUFFIX).newInstance();
      if (debug) Log.d(TAG, "HIT: Class loaded injection class.");
    } catch (ClassNotFoundException e) {
      if (debug) Log.d(TAG, "Not found. Trying superclass " + cls.getSuperclass().getName());
      injector = findInjectorForClass(cls.getSuperclass());
    }
    INJECTORS.put(cls, injector);
    return injector;
  }

  public Router registerRoutes(Class<?>... targets) {
    for (Class<?> target: targets) {
      if (Activity.class.isAssignableFrom(target) && target.isAnnotationPresent(Routable.class)) {
        Routable routable = target.getAnnotation(Routable.class);
        if (debug) Log.d(TAG, routable.toString());

        String[] routes = routable.value();
        if (routes != null) {
          for (String route: routes) {
            @SuppressWarnings("unchecked")
            Class<? extends Activity> activityTarget = (Class<? extends Activity>) target;
            map(route, activityTarget);
          }
        }
      }
    }
    return this;
  }
}
